\section{Development}
The development was carried out in natural stages of adding complexity.
To understand what to do, the team read the recepie in the compendium, and looked up the registers used in the EFM32GG reference manual.

\subsection{Aliasing Registers}
The base addresses \texttt{GPIO\_PA}, \texttt{GPIO\_PC} and \texttt{GPIO\_BASE} were often used troughout the code.
These constants had too high precision to be used as immediate values, so they needed to be loaded using a special form of the \texttt{LDR} instruction:

\begin{minted}{objdump}
ldr r4 =GPIO_PA
\end{minted}

This instruction will cause the assembler to place the constant in a \emph{literal pool} in the text section and emits a instruction to load from that.
Dissasembling shows that the literal pool is at the very end of the program text, but this might have been different if the program were very long.

To avoid having to do this load every time the constants are needed, both for convenience and optmizing for fewer instructions, the registers r4--r6 where allocated excusivly for these constants.
This using the \texttt{.req} directive of the assembler convenient aliases for the registers were named:

\begin{minted}{objdump}
GPIO_I .req r4
ldr r4 =GPIO_PC

GPIO_O .req r5
ldr r5 =GPIO_PA

GPIO .req r6
ldr r6 =GPIO_BASE
\end{minted}


\subsection{Clocking the GPIO controller}
The EFM32GG has external controllers memory mapped.
One of them is a GPIO-controller.
At startup, to save power, the external controllers are not clocked.
As such it is not possible to comunicate with the controller.
Before the GPIO-controller can be configured, the CMU must be set to enable the HFPERCLK for the GPIO-controller.
This is done by setting bit 13 in the CMU\_HFPERCLKEN0 register.

\begin{minted}{objdump}
    ldr r1 [GPIO, #CMU_HFPERCLKEN0]
    orr r1, #(1<<CMU_HFPERCLKEN0_GPIO)
    str r1, [GPIO, #CMU_HFPERCLKEN0]
\end{minted}


\subsection{Lighting the LEDs}
The first course of action was to allow the program to control the LEDs.
This allows for some rudimentary output, and is a nessesary first step to complete the assignment.
The folowing configuration was used for port C:

Set the alternative drive strength to \SI{2}{\milli\ampere}:
\begin{minted}{objdump}
    ldr r1, =0x3
    str r1, [GPIO_O, GPIO_CTRL]
\end{minted}

Set the mode of pins 8--15 to push-pull (output) with alternative drive strength:
\begin{minted}{objdump}
    ldr r1, =0x55555555
    str r1, [GPIO_O, GPIO_MODEH]
\end{minted}

Turn off a pattern of the LEDs by setting outputs of even pins 8--15 to high:
\begin{minted}{objdump}
    ldr r1, =0xaa00
    str r1, [GPIO_O, GPIO_DOUT]
\end{minted}

This produced the expected pattern on the ligths.


\subsection{Reading input}
The next step was to show which buttons are pressed using the lights.
To do that input was configured on port A pins 0--7 with pull-ups.

Set pull direction of pins 0--7 to up:
\begin{minted}{objdump}
    ldr r1, =0x00ff
    str r1, [GPIO_I, GPIO_DOUT]
\end{minted}

Set mode of pins 0--7 to input with pull and glich filter enabled:
\begin{minted}{objdump}
    ldr r1, =0x33333333
    str r1, [GPIO_I, GPIO_MODEL]
\end{minted}

At this point, input could be read of off GPIO\_PA\_DIN.
This was tested in the debugger:
\todo{Show steps}

Then the input was shown on the LEDs.
The left shift maps the inputs on pins 0--7 to the outputs on 8--15:
\begin{minted}{objdump}
loop:
    ldr r1, [GPIO_I, GPIO_DIN]
    lsl r1, r1, #8
    str r1, [GPIO_O, GPIO_DOUT]
    b loop
\end{minted}
